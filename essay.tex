\documentclass[twoside,titlepage,11pt]{article}
\usepackage[a4paper]{geometry}
\usepackage{url,amssymb}
\title{The Category of Sets in Higher-Order Logic}
\author{Ramana Kumar\\MPhil in Advanced Computer Science\\Peterhouse}
\begin{document}
\maketitle
\section{Introduction}%500{{{
%motivation 300
Category theory provides a framework for studying various notions common to diverse areas of mathematics.
It has applications in computer science ranging from the semantics of programming languages and formal systems to models of concurrency <refs>.
Since its inception, category theory has challenged the traditional foundations of mathematics, namely in set theory, by dealing with collections that are too large to be sets. 
Several workarounds have been discovered over the years, and it is often possible to set things up so they work fine for the problem at hand, but do not capture the full implied generality of the categorical constructions.

Formalisation is a good way to test the limits of foundational choices, because a formal development must respect those choices without resorting to arguments or constructions by analogy or generalisation that are tempting when the foundations come unstuck.
Several formalisations of category theory in different frameworks, with varying coverage and purposes, have been developed.
In this essay, we shall investigate the foundational issues and see some of the solutions, including a new refinement of previous approaches in higher-order logic.

Higher-order logic is an expressive and convenient formal system in which to formalise much mathematics.
As a result, it is the logic implemented by many proof assistants in which formal mathematics has been developed <refs>.
Notable alternatives are set theory in first-order logic, as in Mizar, and more expressive type theories like the logic of Coq or of Agda. <Metamath?>
Higher-order logic has a standard semantics in set theory, and therefore cannot capture large categorical constructions directly, unlike systems whose semantics include, for example, infinite hierarchies of universes.
However, it can be extended with extra axioms asserting the existence of large classes.

%contributions 200
We describe a formalisation of the category of sets, the simplest foundationally tricky category, in higher-order logic so extended.
This development is done in a way that fits naturally into the idiom of the logic but can still express some basic but foundationally-challenging categorical results.
It is not obvious that this approach can be pushed very far.
We comment on the problems and make brief speculations on what a satisfying formalisation of category theory would require and would look like.
%}}}
\section{Background}%1200{{{
We will stay at a relatively high level throughout the essay.
In this section, we give an overview of category theory and of mechanical formalisation, in particular using higher-order logic.
Then we examine the difficulties a formalisation of category theory might face.
\subsection{Category Theory}%400{{{
Category theory is an abstract theory of functions and composition.
A category is an arena in which composition takes place, and consists of \emph{morphisms}, abstract functions, \emph{objects}, the possible domains and codomains of the morphisms, and a composition law, obeying certain conditions.
Let us write $f:A\to B$ for a morphism $f$ with domain $A$ and codomain $B$.
The conditions for a \emph{category} are that there is a composite morphism $g\circ f:A\to C$ whenever $f:A\to B$ and $g:B\to C$ are morphisms of compatible types, composition is associative ($f\circ(g\circ h)=(f\circ g)\circ h$), and there is an \emph{identity} morphism ${1_A}:A\to A$ for every object (${1_A}\circ f=f$ and $g\circ{1_A}=g$ whenever the composites are defined).%100

A highly intuitive (but foundationally tricky) example is the category sets, whose objects are sets and morphisms are functions\footnote{with specified domain and codomain, so for example the empty functions $\bot:\emptyset\to\emptyset$ and $\bot:\emptyset\to\mathbb{N}$ are distinct}: function composition gives the composition law and every set has an identity function.
The morphisms in a category do not have to resemble functions so closely.
%Every group is a category with a single object whose morphisms are the elements of the group with composition given by the group multiplication, since the multiplication in any group must be associative and have an identity element.
Every partially ordered set is a category with a morphism from $A$ to $B$ exactly when $A\leq B$: transitivity gives composites and reflexitivy gives identities.
To study a very simple programming language, we might consider a category whose objects are types and morphisms are computable total functions, which is essentially (a subcategory of) the category of sets.
For languages with recursion, we might use a category of domains and continuous functions, and there are other categories suited to other language features (side-effects, state, concurrency, and so on).%100

Examples of categories are abundant, and notions defined in terms of categories can reveal links between diverse areas.
A map from the objects and morphisms of one category to the objects and morphisms of another is called a \emph{functor} when it preserves identities and composites.
For example, there is a list functor from the category of types to itself that sends a type $\alpha$ to the type of lists with elements of type $\alpha$, and sends a function on elements to the corresponding element-wise function on lists.
<natural transformations, functor categories, Yoneda>
<limits, adjunctions, duality>%100

<category theory is very general/meta/applicable: applies not just to particular objects (poset, monoid), but also to the whole class of sets, groups, etc. (concrete categories), to the whole field of mathematical logic (doctrines, institutions etc.), even to itself (category of categories etc.)>%100
%}}}
\subsection{Mechanisation}%150{{{
Results in mathematics are theorems proved by deduction.
At a high level of formality, they are stated in a formal language and proved by application of syntactic rules.
The formulation of theorems and proofs is often done with less formality because it can be more productive or important to concentrate on intuitions and to make sure the mathematical model is going to accurately capture properties of the problem at hand.
In the end, however, formality is desirable for precision, for avoiding mistakes, and for ensuring consistency.%80

\emph{Mechanical proof checking} refers to the practice of running the steps of a formal derivation as a computer program implementing the rules of a formal system.
Nowadays this represents the highest level of formality.
It carries the burden of coaxing a machine into stepping through even trivial steps in a derivation, although the level of automation is ever improving.
The extra work for a mechanical formalisation is often warranted by one of two situations.
The first is that the model being formalised is intricate or large but not necessarily with much mathematically interesting structure.
For example, formal semantics of a programming language, or a hardware model of a central processing unit.
The second is to see how and whether a theory fits into a particular formal system, namely the one implemented by the proof assistant, to test either the consistency of the theory or the expressiveness of the formal system.
<in this case, the fact that category theory forces us to question foundations (because it is always meta) make it interesting to see how why and where formalisation suffers, and how it can be ameliorated, even if consistency isn't really suspect>%70
%}}}
\subsection{Higher-Order Logic}%200{{{
Higher-order logic is a formal system that has proved popular
<the logic and its characteristics>%50
<syntax and semantics>%100
<the theorem prover>%50
%}}}
\subsection{Formalisation Difficulties}%450{{{
<foundations and size>%250
  <maths usually based on sets, but want to talk about larger collections than can fit in a set in category theory>
  <example>
  <would want to talk about category of categories if possible (but note Coquand's proof that it doesn't exist)>

There are a few more issues than size that make category theory difficult to formalise, which we now review.
<internalisation>%60
  <example>
<equality and isomorphism>%60
  <example>
  <chosen limits, on the nose, etc.>

Finally, there are two issues that affect mechanisations, as opposed to unmechanised formalisation, and are particularly relevant to category theory.
<mechanisation>
  <readability>%40
    <hidden arguments, diagrammatic reasoning>
    <example>
  <automation>%40
    <morphism equality and composability (composition associativity), dependent type inference> 
    <there may be algorithms for doing these things: sometimes the difficulty is integrating the algorithm in the right way to your development within a general-purpose proof assistant>
    <example>
%}}}%}}}
\section{Existing Mechanisations}%1050{{{
<overview>%100
<type theory>%300
  <Huet+Saibi, plus anything else based on Setoids>%60
  <Megacz, Sozeau, plus anything else based on type classes>%60
  <Simpson>%140
  <type theory not in Coq>%40
<set theory etc.>%200
  <Mizar>%60
  <NaDSet>%100
  <anything else>%40
<HOL>%450
  <Agerholm>%100
  <Dawson>%50
  <O'Keefe>%100
  <Katovsky>%200
%}}}
\section{A New Approach in HOL}%1250{{{
\subsection{Design Choices}%300{{{
%}}}
\subsection{Two Categories of Sets}%300{{{
%}}}
\subsection{The Yoneda Embedding}%350{{{
%}}}
\subsection{Limits}%200{{{
%}}}
\subsection{Summary}%100{{{
%}}}
%}}}
\section{Conclusion}%500{{{
<summary>%100
<immediate future work>%200
<future directions>%200
%}}}
\bibliographystyle{plain}
\bibliography{essay}
\end{document}
% vim:fdm=marker
