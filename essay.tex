\documentclass[twoside,titlepage,11pt]{article}
\usepackage[a4paper]{geometry}
\usepackage{url,amsmath,amssymb}
\title{The Category of Sets in Higher-Order Logic}
\author{Ramana Kumar\\MPhil in Advanced Computer Science\\Peterhouse}
\begin{document}
\maketitle
\section*{Declaration}%{
\thispagestyle{empty}
I Ramana Kumar of Peterhouse, being a candidate for the MPhil in Advanced Computer Science, hereby declare that this research essay and the work described in it are my own work, unaided except as may be specified below, and that the research essay does not contain material that has already been used to any substantial extent for a comparable purpose.

\vspace{1em}
\noindent Signed

\vspace{1em}
\noindent Date

\vspace{2em}
\noindent Words: 5158
\vspace{5em}
%}
\section*{Acknowledgements}%{
I thank my supervisor, Sam Staton, for many helpful discussions and comments.
I also thank Mike Gordon, Paul Giannaros, and Zongyan Huang for reading a draft and providing feedback.
Special thanks to Roger Jones for his detailed reading and criticism.
%}
\begin{abstract}%{
The foundational difficulties presented by category theory make it difficult to formalise.
Nevertheless, it is possible to formalise category theory in higher-order logic, extended with a type of small sets, in a way that fits naturally into the idiom of the logic but can still express some basic but foundationally-challenging categorical results.
It is not obvious that this approach can be pushed very far.
A more satisfying formalisation of category theory may require new foundations for abstract mathematics.
\end{abstract}%}
\section{Introduction}%365/300%{
Category theory provides a framework for studying notions common to diverse areas of mathematics.
It has applications in computer science ranging from semantics of formal systems (e.g., \cite{CroleCT,JacobsCLTT}) to models of concurrency~\cite{DBLP:conf/csl/CattaniW96}.
Since its inception, category theory has challenged the traditional foundations of mathematics, namely in set theory, by dealing with collections that fail to be sets.

Formalisation is a good way to test the limits of foundational choices, because a formal development must respect those choices throughout.
There is no resort to arguments by analogy or implied generalisation, especially in formalisations developed mechanically with a proof assistant.
In this essay we present a new mechanisation of category theory\footnote{Our proof scripts are available online at \url{https://github.com/xrchz/HOL/tree/category/examples/category}, as well as in the HOL4 repository (\url{http://sf.net/projects/hol/develop}) from revision <9115?>.}, refining two previous developments in higher-order logic, and investigate the foundational issues.

Higher-order logic (HOL)\footnote{By HOL we mean the logic implemented by the HOL4 theorem prover~\cite{DBLP:conf/tphol/SlindN08}.} is a simple but expressive formal system, implemented by many proof assistants.
HOL has a semantics in set theory without inaccessible cardinals, and therefore cannot capture large categorical constructions directly.
However, it can be extended with extra axioms that assert the existence of large collections.

We formalise the category of sets in higher-order logic so extended.
We try to fit naturally into the idiom of the logic while retaining the ability to express some basic but foundationally-challenging categorical results.
We comment on the limitations of our approach and compare our mechanisation to others.

This essay is structured as a high-level tour of our mechanisation, with discussions of foundational issues, and comparisons to existing work, as they come up.
We begin with an introduction to HOL, then look at our formalisation of category theory, the category of sets in particular, how we treat the Yoneda embedding, and the start of work on categorical limits.

The discussion is suitable for readers unfamiliar with either category theory or theorem proving in HOL, although they may prefer to skim over the displayed formulae giving select definitions and theorems from our development.
We assume passing acquaintance with introductory logic, set theory, and type theory.
%}
\section{Higher-Order Logic}%403/400%{
\newcommand{\bool}{\ensuremath{\mathsf{bool}}}
Higher-order logic (HOL) is a formal system that has proved popular for formalising mathematics as well as properties of hardware and software.
HOL is a sequent calculus with the syntax of the simply typed lambda calculus.
A term of Boolean type is called a \emph{formula}.
HOL has four formulae specified as axioms and a dozen rules of inference; a \emph{theorem}, $\vdash\phi$, is a formula $\phi$ proved from the axioms using the rules.
HOL is implemented by several mechanical proof assistants, including Isabelle~\cite{DBLP:conf/tphol/WenzelPN08}, HOL4~\cite{DBLP:conf/tphol/SlindN08}, HOL-Light~\cite{DBLP:conf/tphol/Harrison09a}, and ProofPower~\cite{ProofPower}.
Our development was done in HOL4, inspired by existing mechanisations \cite{Katovsky,DBLP:journals/entcs/OKeefe04} in Isabelle.

Every term $t$ has a unique type $\tau$ (this is written $t:\tau$).
A type is either a type variable ($\alpha$, $\beta$, ...) or a type operator applied to argument types ($(\tau_1,\tau_2,\dots)\;\mathsf{op}$).
Terms whose types include type variables are said to be \emph{polymorphic}.
For example, there is a polymorphic constant $\mathtt{=}:\alpha\to\alpha\to\bool$, representing equality at every type $\alpha$.
In the semantics of HOL, the meaning of a type is a non-empty set, and the meaning of a term is an element of its type (after, in the case of polymorphic terms, assigning non-empty sets to the type variables).

A \emph{predicate} is a term of type $\alpha\to\bool$ for some type $\alpha$.
The type $\alpha\to\bool$ is abbreviated by $\alpha\;\mathsf{set}$: a predicate on $\alpha$ is the characteristic function of a subset of elements of type $\alpha$.
HOL4 includes much support for the representation of sets as predicates; we use mathematical notation (such as $\{f\;x\mid P\;x\}$) for HOL sets.
The constantly true predicate is denoted $\mathtt{UNIV}$.

Boolean connectives are defined as functions in HOL, for example conjunction has type $\bool\to\bool\to\bool$.
In addition to the standard connectives and quantifiers, HOL includes a \emph{Hilbert choice} term that, given a predicate $P$ as argument, denotes an arbitrary (but fixed) element $c$ such that $P\; c$ holds, if any such element exists, otherwise denotes an arbitrary element (of the right type).
The behaviour of Hilbert choice is one of the axioms of HOL.
The primitive rules of inference include, for example, modus ponens, reflexivity of equality, and generalisation (universal quantification) of free variables.

HOL provides principles for defining new types and new (term) constants.
The primitive types include function types ($\alpha\to\beta$ with arguments $\alpha$ and $\beta$) and Booleans ($\bool$).
Standard defined types include the type $\mathsf{unit}$ with a single element $()$, the option type with constructors $\mathtt{NONE}:\alpha\;\mathsf{option}$ and $\mathtt{SOME}:\alpha\to\alpha\;\mathsf{option}$, and products ($\alpha\times\beta$ with arguments $\alpha$ and $\beta$).
Generalising product types, we can define record types given the desired names and types of the record fields.
New terms can be defined using existing ones, like in a functional programming language.
%}
\section{Composable Morphisms and Categories}%1474/1400%{
Category theory is an abstract theory of functions and composition.
A category is an arena in which composition takes place, and consists of \emph{morphisms}, abstract functions, \emph{objects}, the possible domains and codomains of the morphisms, and a \emph{composition law}, obeying certain conditions.
We define a type of morphisms in HOL as a polymorphic record $$(\alpha,\beta,\gamma)\;\mathsf{morphism}=\langle\mathtt{dom}:\alpha,\,\mathtt{cod}:\beta,\,\mathtt{map}:\gamma\rangle$$
We use a polymorphic record for categories\footnote{This is just the data; the conditions come later.} as well ($(\alpha,\beta)\;\mathsf{mor}$ abbreviates $(\alpha,\alpha,\beta)\;\mathsf{morphism}$):
\begin{align*}
(\alpha,\beta)\;\mathsf{category}=\langle&\mathtt{obj}:\alpha\;\mathsf{set},\,\mathtt{mor}:(\alpha,\beta)\;\mathsf{mor}\;\mathsf{set},\,\mathtt{id}:\alpha\to\beta,\\&\mathtt{comp}:(\alpha,\beta)\;\mathsf{mor}\to(\alpha,\beta)\;\mathsf{mor}\to\beta\rangle
\end{align*}
Thus an $(\alpha,\beta)\;\mathsf{category}$ has objects of type $\alpha$ and morphisms of type $\beta$ (wrapped in $(\alpha,\beta)\;\mathsf{mor}$ records).
The $\mathtt{id}$ and $\mathtt{comp}$ fields, intended to assign an identity morphism to every object and a composite morphism to every pair of composable morphisms, just return the $\mathtt{map}$ field because the $\mathtt{dom}$ and $\mathtt{cod}$ fields can be inferred: we define $\mathtt{id\_in}\;c\;x=\langle\mathtt{dom}=x,\,\mathtt{cod}=x,\,\mathtt{map}=c.\mathtt{id}\;x\rangle$ and $\mathtt{compose\_in}$ similarly.

As a very simple example, we define the discrete category (which has no morphisms except identity morphisms) on a set $s$ as follows:
\begin{align*}
\mathtt{discrete\_cat}\;s=\langle&\mathtt{obj}=s,\,\mathtt{mor}=\{\mathtt{discrete\_mor}\;x\mid x\in s\},\\&\mathtt{id}=\lambda{x}.\;(),\,\mathtt{comp}=\lambda{f,g}.\;()\rangle
\end{align*}
where $\mathtt{discrete\_mor}\;x=\langle\mathtt{dom}=x,\,\mathtt{cod}=x,\,\mathtt{map}=()\rangle$.
If $s:\alpha\;\mathsf{set}$ then $\mathtt{discrete\_cat}\;s:(\alpha,\mathsf{unit})\;\mathsf{category}$.
Every category $c$ has an opposite category $c^{\mathrm{op}}$, which provides another example definition:
\begin{align*}
\mathtt{op\_cat}\;c=\langle&\mathtt{obj}=c.\mathtt{obj},\,\mathtt{mor}=\{\mathtt{op\_mor}\;f\mid f\in c.\mathtt{mor}\},\,\mathtt{id}=c.\mathtt{id},\\&\mathtt{comp}=\lambda{f,g}.\;c.\mathtt{comp}\;(\mathtt{op\_mor}\;g)\;(\mathtt{op\_mor}\;f)\rangle
\end{align*}
where $\mathtt{op\_mor}\;f=\langle\mathtt{dom}=f.\mathtt{cod},\,\mathtt{cod}=f.\mathtt{dom},\,\mathtt{map}=f.\mathtt{map}\rangle$.

We look at two previous formalisations of category theory in detail, one by Greg O'Keefe in 2004~\cite{DBLP:journals/entcs/OKeefe04} and another by Alex Katovsky in 2010~\cite{Katovsky}.
Both also use a polymorphic record type for categories.
However, their categories have two additional fields of type $\beta\to\alpha$ intended to assign a domain and codomain to each morphism: there is no separate record for morphisms.
The advantage of having morphisms independent of categories (also done by Simpson~\cite{Simpson04}) is that notions like composability and composition can be defined generically then applied when there is no containing category.

Functors and natural transformations can be defined as instances of morphisms (between categories and between functors respectively) rather than as new record types.
For example, we use $(\alpha,\beta,\gamma,\delta)\;\mathsf{functor}$ to abbreviate the type \[((\alpha,\beta)\;\mathsf{category},(\gamma,\delta)\;\mathsf{category},(\alpha,\beta)\;\mathsf{mor}\to(\gamma,\delta)\;\mathsf{mor})\;\mathsf{morphism}\] whose instances we intend to be functors from an $(\alpha,\beta)\;\mathsf{category}$ to a $(\gamma,\delta)\;\mathsf{category}$.
A functor's $\mathtt{map}$ field gives its action on morphisms; following Katovsky we omit the action on objects, since it can be defined (using Hilbert choice) from the action on identity morphisms.

Instances of the $\mathsf{morphism}$ record are not necessarily attached to any instance of the $\mathsf{category}$ record.
It could be argued, however, that all composable morphisms occur in some category.
For example, functors are the morphisms in a category of categories.
However, this notion is problematic for several reasons, one being that objects in our categories all have the same type, but we make use of functors between categories of different types.
Indeed, the separation of elements into different types in the semantics of HOL, a feature common to all type theories, presents difficulties whenever we want to collect elements across types into a totality.

Categories are abstract structures---many different things can play the roles of objects and morphisms---so it is natural to use a polymorphic type to model categories in HOL.
Polymorphism enables the same definition of $\mathtt{id\_in}$ to be used for categories with all different types.
At the same time, polymorphism prevents us from collecting all categories in a single HOL set: in forming a term of type $(\alpha,\beta)\;\mathsf{category}\;\mathsf{set}$ we fix the types $\alpha$ and $\beta$, and therefore the set denoted cannot contain, for example, an element of type $(\alpha\times\alpha,\beta)\;\mathsf{category}$.

Coquand~\cite{DBLP:conf/lics/Coquand86} has shown that a category of categories cannot exist in many frameworks, because it leads to paradox.
It is a useful idea to consider, nonetheless: for example, given two categories we can define their product, and we would like to apply general theorems about products within a category to it.
The usual mathematical workaround is to stratify categories into bands of different sizes, and use the category of (relatively) small categories, which is itself not small.
This stratification can be achieved, to some extent, by \emph{universe polymorphism} in Coq (a proof assistant for dependent type theory, see~\cite{DBLP:conf/tphol/Bertot08}), as in Huet and Sa{\"i}bi's mechanisation~\cite{DBLP:conf/birthday/HuetS00}.
When we define the product of an $(\alpha,\beta)\;\mathsf{category}$ and a $(\gamma,\delta)\;\mathsf{category}$, however, it has type $(\alpha\times\gamma,\beta\times\delta)\;\mathsf{category}$.
Terms with these types could not all be objects of a $(\tau_1,\tau_2)\;\mathsf{category}$ for any (fixed) types $\tau_1$ and $\tau_2$.

Let us look now at a longer example of this problem.
In category theory, the notion of \emph{isomorphism} plays a role similar to, and often more important than, equality.
An isomorphism is a morphism with an inverse (for composition), and two objects are isomorphic if there is an isomorphism between them.
We define what it means for a pair of morphisms to be inverses:
\begin{align*}
\mathtt{iso\_pair}\;c\;f\;g\iff f\leadsto g\operatorname{\mathtt{-:}}c\land f\circ g\operatorname{\mathtt{-:}}c=\mathtt{id}\;g.\mathtt{dom}\operatorname{\mathtt{-:}}c\land g\circ f\operatorname{\mathtt{-:}}c=\mathtt{id}\;f.\mathtt{dom}\operatorname{\mathtt{-:}}c
\end{align*}
The notation $f\leadsto g\operatorname{\mathtt{-:}}c$ abbreviates composability within a category: $f.\mathtt{cod}=g.\mathtt{dom}\land f\in c.\mathtt{mor}\land g\in c.\mathtt{mor}$.
Similarly $f\circ g\operatorname{\mathtt{-:}}c$ abbreviates composition ($\mathtt{compose\_in}$) and $\mathtt{id}\;x\operatorname{-:}c$ an identity morphism ($\mathtt{id\_in}$).
We define $\mathtt{iso}\;c\;f \iff\exists{g}.\;\mathtt{iso\_pair}\;c\;f\;g$.

The morphism $f$ in the definition of $\mathtt{iso}$ has type $(\alpha,\beta)\;\mathsf{mor}$, where $\alpha$ is the type of both the domain and codomain of the morphism.
Therefore if we want to consider an isomorphism between categories (a functor that is an isomorphism), we cannot use $\mathtt{iso}$ unless the functor is between categories of the same type (e.g., we could instantiate $\alpha$ with $(\gamma,\delta)\;\mathsf{category}$ then $f$ would have type $(\gamma,\delta,\gamma,\delta)\;\mathsf{functor}$).
We define another notion, $\mathtt{cat\_iso}$, to cover functors of arbitrary types, by replacing all the ``$\operatorname{\mathtt{-:}}c$'' notions above (e.g., replace $f\circ g\operatorname{\mathtt{-:}}c$ by functor composition).

Theorems stating properties of isomorphisms (like that the notion is symmetric) need to be repeated for both $\mathtt{iso\_pair}$ and $\mathtt{cat\_iso\_pair}$. 
This situation shows the polymorphic record approach to categories getting in the way of expressing general categorical properties.
We could try using a general definition of isomorphism, outside of any category.
But doing so would be unwieldy: such a definition would need to take two copies each (to ensure a general type) of an identity map and a composition rule as arguments.

Having looked at some of the problems due to the type system and our use of a polymorphic record, we return to describing our development.
An element of the $\mathsf{category}$ type is not necessarily a category.
We define a predicate $\mathtt{category\_axioms}:(\alpha,\beta)\;\mathsf{category}\to\mathsf{bool}$ that checks whether a record satisfies the conditions required of a category (e.g., composition is associative, every composable pair has a composite), and include a hypothesis that the predicate is true in our theorems about categories.
We can prove, for example, $\vdash\forall{c}.\;\mathtt{category\_axioms}\;c\implies\mathtt{category\_axioms}\;(\mathtt{op\_cat}\;c)$.

As noted by Katovsky, we need to impose an additional restriction that the identity and composition fields send elements outside their domain to a specific ``undefined'' value, which we call $\mathtt{ARB}$.
This is because functions in HOL are total, but we are using them to model partial functions.
For example, if $x,y\notin c.\mathtt{obj}$ then we want $c.\mathtt{id}\;x=c.\mathtt{id}\;y$ even though the value of $c.\mathtt{id}\;x$ will never feature in any proof within the category $c$.
We call this kind of restriction \emph{extensionality}\footnote{The adjective ``canonical'' might be better than ``extensional'': we are picking canonical representatives in the collection of total functions that agree on a given domain (thereby making the collection of canonical representatives extensional).}.

We impose the same restriction wherever partial functions arise, for example the morphism map of a functor $G$ is restricted to $G.\mathtt{dom}.\mathtt{mor}$.
A non-extensional function (taking values other than $\mathtt{ARB}$ outside its desired domain) can easily be made extensional: we use $$\mathtt{restrict}\;f\;s=\lambda{e}.\;\mathtt{if}\;e\in s\;\mathtt{then}\;f\;e\;\mathtt{else}\;\mathtt{ARB}$$ to restrict $f:\alpha\to\beta$ to $s:\alpha\;\mathsf{set}$.
We define $\mathtt{is\_category}\;c=\mathtt{category\_axioms}\;c\land\mathtt{extensional\_category}\;c$, where the second conjunct ensures $c.\mathtt{id}$ and $c.\mathtt{comp}$ are extensional.
In a dependently typed setting, both the category axioms and extensionality can be encoded directly in the definition of the $\mathsf{category}$ type (as in~\cite{DBLP:conf/birthday/HuetS00,Sozeau,Megacz}).

Extensionality enables us to characterise equality between natural transformations as follows (where $\mathtt{is\_nt}$ is like $\mathtt{is\_category}$ but for natural transformations):
\begin{align*}
\vdash\forall{\eta,\mu}.\;&\mathtt{is\_nt}\;\eta\land\mathtt{is\_nt}\;\mu\land(\eta.\mathtt{dom} = \mu.\mathtt{dom})\land(\eta.\mathtt{cod} = \mu.\mathtt{cod})\land{}\\
&(\forall{x}.\;x\in \eta.\mathtt{dom}.\mathtt{dom}.\mathtt{obj}\implies(\eta.\mathtt{map}\;x= \mu.\mathtt{map}\;x))\implies (\eta = \mu)
\end{align*}
(and similarly for categories and functors).
Given a functor $F$, we can define a natural transformation $\mathtt{id\_nt}\;F$ whose component at $x$ is the identity morphism for $F$'s action on $x$.
Our theorem about natural transformation equality lets us prove
\[\vdash\forall{\eta}.\;\mathtt{is\_nt}\;\eta\implies(\eta\circ\mathtt{id\_nt}\;\eta.\mathtt{dom} = \eta)\]
because our definition of natural transformation composition (the $\circ$ operator above) produces an extensional natural transformation, so comparison with $\eta$ depends only on categorical properties.
We have defined, for any two categories $c_1$ and $c_2$, the category $[c_1\to c_2]$ of functors between them with natural transformations as morphisms, where $\mathtt{id\_nt}$ provides identity morphisms.
%mention postcomp_functor as an example of something proved using functor categories?

An alternative approach to categories gives a set of morphisms, called a \emph{hom}, for each type (pair of objects) rather than giving all the morphisms at once.
This has not been formalised in HOL, but is used by Huet and Sa{\"i}bi, for example.
We can define homs after categories: $\mathtt{hom}\;c\;x\;y=\{f\mid f.\mathtt{dom}=x\land f.\mathtt{cod}=y\land f\in c.\mathtt{mor}\}$.
The approaches are essentially equivalent, because if we defined categories in terms of homs, we could then define the collection of all morphisms in a category as $\mathtt{mor}\;c=\{f\mid\exists{x,y}.\;x\in c.\mathtt{obj}\land y\in c.\mathtt{obj}\land f\in c.\mathtt{hom}\;x\;y\}$.
%An advantage of starting with homs instead might be that we could put off mentioning the collection of all morphisms.
%We will return to this point in Section~\ref{Yoneda} when describing locally small categories.

Another choice is whether to include objects at all: we might avoid the $\mathtt{obj}$ field by identifying objects with identity morphisms, as explained in pages 41--43 of \cite{DBLP:books/daglib/0023249}.
This approach is taken by Roger Jones~\cite{RBJones17}, and allows a much slicker presentation than ours (for example, functors are just HOL functions).
Categories are still polymorphic, but with just one type variable (for morphisms).
%}
\section{Two Categories of Sets}%1394/1400%{
\label{Set}
\newcommand{\Set}{\ensuremath{\mathbf{Set}}}
The category $\Set$ of sets has sets as objects and functions with specified domain and codomain\footnote{so for example the empty functions $\bot:\emptyset\to\emptyset$ and $\bot:\emptyset\to\mathbb{N}$ are distinct} as morphisms.
A natural approach to defining $\Set$ in HOL is as an instance of the $\mathsf{category}$ record where $\mathtt{obj}:\alpha\;\mathsf{set}\;\mathsf{set}$ and the $\mathtt{map}$ field of each morphism is a function $\alpha\to\alpha$.
This is the approach taken by O'Keefe, which we follow by defining a category of ``sets within a universe'':
\begin{align*}
&\mathtt{ens\_cat}\;(u:\alpha\;\mathsf{set}\;\mathsf{set})=\\
&\quad\langle\mathtt{obj}=u,\\
&\quad\phantom{\langle}\mathtt{mor}=\{f:(\alpha\;\mathsf{set},\alpha\to\alpha)\;\mathsf{mor}\mid \forall{x}.\;x\in f.\mathtt{dom}\implies f.\mathtt{map}\;x\in f.\mathtt{cod}\},\\
&\quad\phantom{\langle}\mathtt{id}=\dots,\,\mathtt{comp}=\dots\rangle
\end{align*}
(we also ensure the morphisms are extensional).
The $\mathtt{ens\_cat}\;u$ category captures one important property of $\Set$, namely, that the morphisms are functions under composition.
It has precedent in Mac Lane's textbook on category theory~\cite{MacLaneCFTWM}, which defines $\mathbf{Ens}_u$ as above for the purpose of generalising arguments in $\Set$ to larger collections $u$ than that of all sets.
However, in our polymorphic setting, $\mathtt{ens\_cat}$ does not capture the idea that \emph{every} set should be an object, even when $u=\mathtt{UNIV}$, and therefore fails to have many properties a category of sets ought to have.

The problem is that $\Set$ is usually formulated in an untyped setting, and when translated to the typed setting it includes functions from sets of elements of one type to those of another.
For example, there is a function from the set of strings $\{\text{``an''},\text{``object''},\text{``in''},\text{``Set''}\}$ to the set of numbers $\{2,3,6\}$ that returns the length of a string, but in HOL, using idiomatic encodings, the former set would have type $\mathsf{string}\;\mathsf{set}$ while the latter would be a $\mathsf{num}\;\mathsf{set}$, and they cannot both be instances of $\alpha\;\mathsf{set}$ at the same time (since $\mathsf{string}$ and $\mathsf{num}$ are different types).

More generally, consider the relationship in any formalisation between the collection of morphisms $c.\mathtt{mor}$ in a category and the notion of a set.
If $c.\mathtt{mor}$ is itself a set, then there is no category whose morphisms are all the functions between sets because no set can contain all functions.
So if we want $\Set$ we must arrange for $c.\mathtt{mor}$ to be some kind of collection that can be larger than a set.

A solution in HOL is to introduce a new type, $\mathsf{zfset}$, representing sets in an axiomatic set theory such as ZFC.
Contrary to the way types are usually introduced in HOL, that is, by definition, the type $\mathsf{zfset}$ is created as a new primitive type (extending the logic) and its properties are asserted as new axioms of HOL.
The new axioms are (higher-order versions of) the axioms of ZFC.
We also define new terms for ZFC set membership ($\mathtt{in}:\mathsf{zfset}\to\mathsf{zfset}\to\mathsf{bool}$), set union, functions as graphs, and so on.

The constantly true predicate of type $\mathsf{zfset}\;\mathsf{set}$ now represents the collection of all ZFC sets.
This method of accessing set theory within the HOL logic was introduced by Mike Gordon \cite{DBLP:conf/tphol/Gordon96} (and independently by Bob Solovay, see~\cite{DBLP:conf/ictac/Obua06}) and is implemented in both HOL4 and Isabelle~\cite{DBLP:conf/ictac/Obua06}.
We use it, following Katovksy, to define a non-polymorphic category of sets with $\mathtt{set\_cat}.\mathtt{obj}:\mathsf{zfset}\;\mathsf{set}$ and $\mathtt{set\_cat}.\mathtt{mor}:\mathsf{zfset}\;\mathsf{set}$ also (since functions between ZFC sets can be encoded as ZFC sets).

It would be reasonable to formalise all categories non-polymorphically, revising our original $\mathsf{category}$ record to have an $\mathtt{obj}$ field of type $\mathtt{zfset}\;\mathtt{set}$.
%(although it might be better to use $\mathtt{obj}:\alpha$ and a convention to only instanstiate $\alpha$ by $\mathsf{zfset}\;\mathsf{set}$ or $\mathsf{zfset}\;\mathsf{set}\;\mathsf{set}$ and so on, to allow arbitrarily large categories).
This approach matches a mathematical view of categories based on set theory extended with proper classes (as in~\cite{MacLaneCFTWM} for example) if we take $\mathtt{zfset}$ seriously as our representation of sets.
However, in HOL we have a competing representation of sets, namely the HOL types.
If we formalise categories purely in terms of $\mathsf{zfset}$, then our categories remain disconnected from other theories we have formalised in HOL using types such as $\mathsf{num}$ and $\mathsf{string}$.
It is for this reason we consider the polymorphic approach to be idiomatic.

Nevertheless, we need to use the ``untyped'' $\mathtt{set\_cat}$ if we want to formalise the many properties of $\Set$ that are lost on $\mathtt{ens\_cat}$.
The reason much mathematics is encoded in set theory in the first place is that the universe of sets supports the encoding of almost all mathematical objects.
We can tap into this idea by treating a HOL set (of type $\alpha\;\mathsf{set}$ for some type $\alpha$) as a ZFC set, in particular by finding a representative element of type $\mathsf{zfset}$ to which the HOL set corresponds.
Since some HOL types contain more elements than there are ZFC sets, though, we can only hope to encode ``small'' HOL sets.
Following ideas from Katovksy, we define a predicate $\mathtt{is\_small}:\alpha\;\mathsf{set}\to\mathsf{bool}$ by $$\mathtt{is\_small}\;s=\exists{f,z}.\;\mathtt{INJ}\;f\;s\;\{x\mid x\operatorname{\mathtt{in}} z\}$$ so a HOL set $s$ is small\footnote{We do not mean \emph{hereditarily} small (or ``low-rank''), which is a common meaning of ``small'' in set theory; we focus just on cardinality.} if there is an injection from $s$ to the (HOL) set of elements of some ZFC set.

Working with $\mathtt{ens\_cat}$ in HOL is easier than with $\mathtt{set\_cat}$, because the morphisms are based on HOL functions directly rather than encodings of ZFC functions as ZFC sets.
We would expect $\mathtt{ens\_cat}$ to be more general than $\mathtt{set\_cat}$, since it is parameterised over an arbitrary collection of sets, and, happily, we can prove that $\mathtt{set\_cat}$ is isomorphic as a category to the $\mathtt{ens\_cat}$ of small sets of ZFC sets.
Specifically, we have proved
\begin{align*}
&\vdash\mathtt{cat\_iso}\;\mathtt{set\_to\_ens}\text{, alongside}\\
&\vdash\mathtt{is\_functor}\;\mathtt{set\_to\_ens}\text{,}\\
&\vdash\mathtt{set\_to\_ens}.\mathtt{dom}=\mathtt{set\_cat}\text{, and}\\
&\vdash\mathtt{set\_to\_ens}.\mathtt{cod}=\mathtt{ens\_cat}\;\{s:\mathsf{zfset}\;\mathsf{set}\mid\mathtt{is\_small}\;s\}\text{.}
\end{align*}
%For the proof, we use the theorem that an isomorphism of categories is the same as a bijection between the classes of objects and between each hom, and the facts that ZFC sets are determined by their members, and explicitly typed ZFC functions correspond to explicitly typed HOL functions (between ZFC sets) by their action under ZFC function application.
We define $\mathtt{ens\_to\_set}$ (using Hilbert choice) as the inverse functor.
This isomorphism provides the initial link between small HOL sets and ZFC sets, but it is useless for arbitrary small HOL sets since the $\mathtt{ens\_cat}$ involved is over a collection of sets of ZFC sets, that is, of type $\mathsf{zfset}\;\mathsf{set}$ rather than $\alpha\;\mathsf{set}$.

To view small HOL sets over an arbitrary type as being in the category of ZFC sets, we must choose a ZFC set to represent each small HOL set.
We choose representatives globally, and once-and-for-all, using Hilbert choice.
First, we characterise smallness as being in bijection with the elements of a ZFC set (the definition only required an injection):
\begin{align*}
\vdash\forall{s}.\;\mathtt{is\_small}\;s\implies\exists{b,z}.\;&\mathtt{BIJ}\;b\;s\;\{\mathtt{SOME}\;x\mid x\operatorname{\mathtt{in}}z\}\land{}\\
&\forall{x}.\;x\notin s\implies(b\;x=\mathtt{NONE})
\end{align*}
(Here we ensure extensionality of the bijection $b$ with the $\mathsf{option}$ type ($\mathtt{SOME}$ versus $\mathtt{NONE}$) rather than with $\mathtt{ARB}$, because $\mathtt{ARB}$ may be in $z$ and we would rather be able to tell whether $x\in s$ from the value of $b\;x$.)
Given this existence theorem, we can define, using Hilbert choice, a constant
$\mathtt{zfrep}$ (for $z$), and constants $\mathtt{zfel}$ and $\mathtt{elzf}$ (for $b$ and its inverse) satisfying the following theorems for any HOL set $s:\alpha\;\mathsf{set}$
\begin{align*}
&\vdash\forall{s,z}.\;\mathtt{is\_small}\;s\implies(z\operatorname{\mathtt{in}}\mathtt{zfrep}\;s\iff\exists{x}.\; x \in s \land z = \mathtt{zfel}\;s\;x)\\
&\vdash\forall{s,x}.\;\mathtt{is\_small}\;s\land x \in s\implies\mathtt{elzf}\;s\;(\mathtt{zfel}\;s\;x) = x\\
&\vdash\forall{s,z}.\;\mathtt{is\_small}\;s\land z \operatorname{\mathtt{in}} \mathtt{zfrep}\;s\implies\mathtt{zfel}\;s\;(\mathtt{elzf}\;s\;z) = z
\end{align*}

Having fixed representative ZFC sets, we can define a functor, $\mathtt{rep\_functor}\;u$, where $u:\alpha\;\mathsf{set}\;\mathsf{set}$ satisfies $\forall{s}.\;s\in u\implies\mathtt{is\_small}\;s$, from $\mathtt{ens\_cat}\;u$ to $\mathtt{ens\_cat}\;\{(s:\mathsf{zfset}\;\mathsf{set})\mid\mathtt{is\_small}\;s\}$.
The action of $\mathtt{rep\_functor}\;u$ on morphisms is given by
\begin{align*}
f\mapsto\langle&\mathtt{dom}=\{z\mid z\operatorname{\mathtt{in}}\mathtt{zfrep}\;f.\mathtt{dom}\},\,\mathtt{cod}=\{z\mid z\operatorname{\mathtt{in}}\mathtt{zfrep}\;f.\mathtt{cod}\},\\
&\mathtt{map}=\lambda{z}.\;\mathtt{zfel}\;f.\mathtt{cod}\;(f.\mathtt{map}\;(\mathtt{elzf}\;f.\mathtt{dom}\;z)\rangle
\end{align*}
Thus, the action on objects is to send a set $s$ (in $u$) to the collection of ZFC sets that are members of the chosen representation of $s$ as a ZFC set.
This kind of translation back and forth between ZFC sets, HOL sets of their elements, and the small HOL sets they might represent is more pervasive in Katovksy's formalisation of $\Set$; we try to contain it all in $\mathtt{rep\_functor}\;u$ so the rest of the development is less cluttered.

The most important property of $\mathtt{rep\_functor}\;u$ is that it is an \emph{embedding}.
In general, a functor is an embedding if it is \emph{full} and \emph{faithful}.
Both notions refer to the action on morphisms of a fixed type: full means surjective on homs and faithful means injective on homs.
An embedding is \emph{essentially injective on objects}, that is, if an embedding sends two objects in the source category to the same object in the target category, then those two objects are isomorphic in the source category.
We have proved, in HOL, that embeddings are essentially injective, and that $\mathtt{rep\_functor}\;u$ is an embedding.

We cannot prove, however, that $\mathtt{rep\_functor}\;u$ is literally injective on objects (if two objects are mapped to the same place they are equal).
To do so would be to conclude that two small HOL sets $s_1$ and $s_2$ are equal just because $\mathtt{zfrep}\;s_1=\mathtt{zfrep}\;s_2$.
But our definition of $\mathtt{zfrep}$ does not ensure injectivity: there is no reason Hilbert choice cannot pick the same ZFC set to represent two small HOL sets of the same cardinality.
Indeed by considering $s_1,s_2\in u$ where $u$ is larger than the collection of all ZFC sets, which is possible when $u:\mathsf{zfset}\;\mathsf{set}\;\mathsf{set}\;\mathsf{set}$, we see that $\mathtt{zfrep}$ could not be injective.
It is unfortunate, but not fatal to our later results, that we cannot ensure literal injectivity of $\mathtt{rep\_functor}\;u$ when $u$ is small.
%}
\section{The Yoneda Embedding}%774/700%{
\label{Yoneda}
\newcommand{\op}{\ensuremath{\sp{\mathrm{op}}}}
\newcommand{\blank}{\rule[0.5ex]{0.6em}{.4pt}}
The Yoneda embedding represents a category $c$ in its category of presheaves $\widehat{c}$.
A \emph{presheaf} is a functor from ${c}\op$ to $\mathbf{Set}$, thus $\widehat{c}$ is a functor category.
The importance of the Yoneda embedding is that $\widehat{c}$ inherits much structure from $\mathbf{Set}$ (e.g., having small limits) so can be used when $c$ itself lacks this structure.
The Yoneda lemma, used to prove that the Yoneda embedding is an embedding, is a basic milestone in any development about the category of sets, and is one of the main results in both O'Keefe's and Katovksy's developments.

The Yoneda embedding sends an object $x$ in $c$ to the \emph{contravariant hom functor} $c(\blank,x)$, which in turn sends an object $y$ in $c$ to $c(y,x)$ (that is, $\mathtt{hom}\;c\;y\;x$).
In order for $c(\blank,x)$ to be a set-valued presheaf, however, every hom $c(y,x)$ must be a set.
A category where every hom is a set is called \emph{locally small}, and it is only for locally small categories that the Yoneda embedding can be defined.
However, the proof of the Yoneda lemma never mentions smallness explicitly, and the argument still goes through when we generalise from the category of sets to an arbitrary category whose objects are appropriately set-like and include the homs of $c$.

Therefore, we prove the Yoneda lemma, and define the embedding, for presheaves whose codomain is $\mathtt{ens\_cat}\;u$.
We require $u$ to contain at least all the homs of $c$.
O'Keefe, who also proves the Yoneda lemma for ``($\mathtt{ens\_cat}\;u$)-valued'' presheaves, takes $u=\mathtt{UNIV}$; we instead take a universe containing only the homs of $c$ (but we define an inclusion functor embedding $\mathtt{ens\_cat}\;u_1$ into $\mathtt{ens\_cat}\;u_2$ whenever $u_1\subseteq u_2$).
We follow Katovsky's organisation of the proof, although our proofs are slightly simpler for avoiding representations as ZFC sets.
The two main definitions are of the Yoneda functor itself, and the natural transformations between hom functors it produces:
\begin{align*}
\mathtt{Yfunctor}\;c&=\langle\mathtt{dom}=c,\,\mathtt{cod}=[c\op\to\mathtt{ens\_cat}\;(\mathtt{homs}\;c)],\,\mathtt{map}=\mathtt{YfunctorNT}\;c\rangle\\
\mathtt{YfunctorNT}\;c\;f&=\langle\mathtt{dom}=c(\blank,f.\mathtt{dom}),\,\mathtt{cod}=c(\blank,f.\mathtt{cod}),\,\mathtt{map}=\lambda{x}.\;c(x,f)\rangle
\end{align*}
(Of course, we actually use restricted definitions so the resulting functor and natural transformation are extensional.)
The notation $c(x,f)$ stands for the action of the covariant hom functor on the morphism $f$, namely \[c(x,f)=\langle\mathtt{dom}=c(x,f.\mathtt{dom}),\,\mathtt{cod}=c(x,f.\mathtt{cod}),\,\mathtt{map}=\lambda{g}.\;f\circ g\operatorname{\mathtt{-:}}c\rangle\text{.}\]
The two main theorems are that the Yoneda functor is an embedding, and is also literally injective on objects:
\begin{align*}
&\vdash\mathtt{is\_category}\;c\implies\mathtt{embedding}\;(\mathtt{Yfunctor}\;c)\text{, and}\\
&\vdash\mathtt{is\_category}\;c\implies\mathtt{inj\_obj}\;(\mathtt{Yfunctor}\;c)\text{.}
\end{align*}

To get a version of $\mathtt{Yfunctor}\;c$ whose codomain is $[c^\mathrm{op}\to\mathtt{set\_cat}]$, we use $\mathtt{rep\_functor}$ and the isomorphism between $\mathtt{set\_cat}$ and the $\mathtt{ens\_cat}$ of small ZFC sets.
We might define
\begin{multline*}
\mathtt{zYfunctor}\;c=\\(\mathtt{postcomp\_functor}\;(c^\mathrm{op})\;(\mathtt{ens\_to\_set}\circ\mathtt{rep\_functor}\;(\mathtt{homs}\;c)))\circ\mathtt{Yfunctor}\;c
\end{multline*}
where $\circ$ is functor composition and $\mathtt{postcomp\_functor}\;b\;f$ converts a functor $f$ from $c_1$ to $c_2$ to a functor from $[b\to c_1]$ to $[b\to c_2]$.
Using our existing theorems about $\mathtt{Yfunctor}\;c$ (along with general theorems about the preservation of embeddings) we can easily prove that $\mathtt{zYfunctor}\;c$ is an embedding whenever $c$ is locally small.
However, we cannot prove that it is injective on objects: the problem is that $\mathtt{rep\_functor}\;(\mathtt{homs}\;c)$ may not be injective on objects (as mentioned above), so if two objects in $c$ have isomorphic contravariant hom functors our embedding might represent them by the same ZFC set.

Mathematically, the Yoneda embedding ought to be (literally) injective on objects.
We can recover injectivity with a tagging trick (due to Sam Staton), by defining
\[\mathtt{zYfunctor}\;c=(\mathtt{postcomp\_functor}\;(c^\mathrm{op})\;(\mathtt{tag\_functor}\;c))\circ\mathtt{Yfunctor}\;c\]
where the action of $\mathtt{tag\_functor}\;c$ on a hom $h$ is the ZFC ordered pair whose first component is the empty ZFC set if $h$ is of the form $c(x,x)$, otherwise it is a singleton ZFC set, and whose second component is just the action of $\mathtt{ens\_to\_set}\circ\mathtt{rep\_functor}\;(\mathtt{homs}\;c)$ on $h$.
The ZFC sets now encode whether they are representing a hom of the form $c(x,x)$ or $c(x,y)$, therefore we can tell functors $c(\blank,x)$ and $c(\blank,y)$ apart (when $x\neq y$) by their action on $x$, even if they are isomorphic functors.

We end this section with a comment about the other mechanisations' treatment of locally small categories.
O'Keefe only proves the Yoneda lemma for $\mathtt{ens\_cat}$ so never needs to distinguish locally small categories.
Katovsky attaches, to categories intended to be locally small, an injective function that picks a ZFC set for each morphism in the category.
The set representing a hom is given by collecting these sets-representing-morphisms as a single ZFC set; if such a ZFC set exists, the hom is small.

Katovsky's approach is problematic for at least two reasons: firstly, locally small categories are not extensional, because the same category equipped with two different representations of its morphisms would be different records in HOL; secondly, it is unnatural to invent a representation of morphisms as sets in order to prove that a category is locally small.
Indeed, there is a locally small category (albeit using our definition of ``small'') that cannot be represented with Katovsky's approach, namely, $\mathtt{discrete\_cat}\;\mathtt{UNIV}$.
This category is locally small because each hom contains at most one morphism, but there is no injective representation of all functions as ZFC sets.
%}
\section{Binary Products and Other Limits}%374/250%{
\label{limits}
Like many constructions in abstract mathematics, \emph{limits} can be presented in different, equivalent ways, at different levels of generality.
We define limits in HOL via \emph{cones}, defined in turn via \emph{comma categories}.
We define binary products as limits of a functor, called $\mathtt{product\_diagram}$, from $\mathtt{discrete\_cat}\;\{1,2\}$.
We have proved a less abstract (standard) characterisation of binary products (the notation $f\operatorname{\mathtt{:-}}x\to y\operatorname{\mathtt{-:}}c$ is shorthand for $f.\mathtt{dom}=x\land f.\mathtt{cod}=y\land f\in c.\mathtt{mor}$):
\begin{align*}
&\vdash\forall{c,a,b,l}.\;\mathtt{is\_category}\;c\land a\in c.\mathtt{obj}\land b \in c.\mathtt{obj}\implies\\
&\quad\mathtt{is\_limit}\;(\mathtt{product\_diagram}\;c\;a\;b)\;l\iff\\
&\quad\exists{ab,p_1,p_2}.\;(l = \mathtt{mk\_cone}\;(\mathtt{product\_diagram}\;c\;a\;b)\;ab\;(\lambda{n}.\; \mathtt{if}\;n = 1\;\mathtt{then}\;p_1\;\mathtt{else}\;p_2))\land{}\\
&\quad\quad p_1\operatorname{\mathtt{:-}}ab \to a\operatorname{\mathtt{-:}}c\land p_2\operatorname{\mathtt{:-}}ab \to b\operatorname{\mathtt{-:}}c\land{}\\
&\quad\quad\forall{ab',p_1',p_2'}.\;
p_1'\operatorname{\mathtt{:-}} ab' \to a \operatorname{\mathtt{-:}}c\land
p_2'\operatorname{\mathtt{:-}} ab' \to b \operatorname{\mathtt{-:}}c\implies\\
&\quad\quad\quad\exists!{m}.\;
m\operatorname{\mathtt{:-}}p\to ab\operatorname{\mathtt{-:}}c\land(p_1\circ m\operatorname{\mathtt{-:}}c = p_1')\land(p_2\circ m\operatorname{\mathtt{-:}}c = p_2')
\end{align*}

The theorem above says that for every pair of objects $a$ and $b$ in a category $c$, there exists a canonical product object $ab$ with projections $p_1$ and $p_2$.
We can use Hilbert choice to define constants $a\times b\operatorname{\mathtt{-:}}c$ , $\pi_1^{a,b,c}$, and $\pi_2^{a,b,c}$ to denote these terms whenever they exist.
Thus we pick arbitrary, but fixed, objects and morphisms to denote ``the'' limit and its projections, which are characterised just by the universal property.
This is in line with mathematical practice.
%<readability?>

We have proved that $\mathtt{set\_cat}$ has all limits of shape $\mathtt{discrete\_cat}\;\{1,2\}$.
Ours is the first mechanisation of limits in HOL (although limits are covered by mechanisations in other formal systems, e.g., \cite{DBLP:conf/birthday/HuetS00,Simpson04}).
The fact that $\mathtt{set\_cat}$ has binary products is reassuring for the approach that models sets with a new type $\mathsf{zfset}$; we would not expect to be able to prove that $\mathtt{ens\_cat}\;\mathtt{UNIV}$ has limits.

An important universal construction that is not an instance of a limit is the function space or exponential object.
One definition gives exponential objects via an exponential functor that is defined as \emph{right adjoint} to the binary product functor.
We can easily define the binary product functor using our work so far on binary products.
However, the best way to treat adjunctions is not obvious.
We could always define exponential objects directly, ignoring the adjunction, but to do so is to miss out on opportunities for abstraction, for proving a theorem once and using it in many different contexts.
%}
\section{Conclusions}%366/300%{
We have looked at a new mechanisation of category theory in higher-order logic.
The foundational difficulties posed by category theory reveal themselves as the following issues during mechanisation:
\begin{itemize}
\item We cannot collect all categories as the objects of a single category.
The separation of categories by HOL types seems not to accommodate a stratification by size (one of the mathematical remedies) well.
\item
As a result, we are forced to define some things (like $\mathtt{iso}$) multiple times: once within our categories, and once for every instance in categories we cannot define.
\item
Since HOL functions are total but the type system is relatively weak, we need to restrict partial functions so that they are extensional, that is, comparable by their action on their domains only.
Extensionality is infectious.
\item
We cannot collect all sets up as a single set, so to formalise the category of sets we need to introduce some notion of proper classes.
\item
We need to reconcile the elements of classes, which are pure ZFC sets for us, with the existing HOL types, which represent sets at the meta-level, by choosing representative ZFC sets for small classes.
\end{itemize}

HOL is a pleasant logic in which to formalise much mathematics; it is unfortunate that it has such difficulties with highly abstract mathematics.
There has been, perhaps, more success in formalising category theory using dependent type theory.
However, the continuing experimentation with approaches to sets---some use setoids~\cite{DBLP:conf/birthday/HuetS00,Carvalho,Wilander}, others the type class mechanism in Coq~\cite{DBLP:conf/mkm/CoquandS07,Sozeau,Megacz}, and yet others import axiomatic set theory somewhat as we do~\cite{Simpson04}---suggest that dependent type theory is not necessarily the final answer (Megacz~\cite{Megacz} does not formalise large categories because ``Coq's universe polymorphism is only $\pi_1$'').

It may be better to do general abstract mathematics in a non-standard formal system.
For example, Jones suggests a non-wellfounded set theory~\cite{RBJones18}.
Gilmore and Tsinkis present category theory without size problems in an unusual natural-deduction-based set theory~\cite{DBLP:journals/tcs/GilmoreT93}. 
%<Systems and Models, Little Theories?>

The foundations of category theory involve interesting problems that have been tackled mathematically and philosophically from the beginning (e.g., \cite{Blass,springerlink:10.1007/BFb0059147}) but the answers are still not completely settled~\cite{Easwaran}.
By pursuing formalisation, we are forced to clarify the issues, and may be driven to solutions that could benefit both category theory and the practice of formalisation itself.
%}
\bibliographystyle{plain}
\bibliography{essay}
\end{document}
% vim:fdm=marker:fmr=%{,%}
