\documentclass[twoside,titlepage,11pt]{article}
\usepackage[a4paper]{geometry}
\usepackage{url,amsmath,amssymb}
\title{The Category of Sets in Higher-Order Logic}
\author{Ramana Kumar\\MPhil in Advanced Computer Science\\Peterhouse}
\begin{document}
\maketitle
\section*{Declaration}%{
\thispagestyle{empty}
I Ramana Kumar of Peterhouse, being a candidate for the MPhil in Advanced Computer Science, hereby declare that this research essay and the work described in it are my own work, unaided except as may be specified below, and that the research essay does not contain material that has already been used to any substantial extent for a comparable purpose.

\vspace{1em}
\noindent Signed

\vspace{1em}
\noindent Date

\vspace{2em}
\noindent Words: 3668
%}
\begin{abstract}%{
The foundational difficulties presented by category theory make it difficult to formalise.
Nevertheless, it is possible to formalise category theory in higher-order logic, extended with a type of small sets, in a way that fits naturally into the idiom of the logic but can still express some basic but foundationally-challenging categorical results.
It is not obvious that this approach can be pushed very far.
A more satisfying formalisation of category theory will require a new way to resolve the foundational issues, a different logic, or a new approach to formalisation.
\end{abstract}%}
\section{Introduction}%295/300%{
Category theory provides a framework for studying various notions common to diverse areas of mathematics.
It has applications in computer science ranging from the semantics of programming languages and formal systems (e.g., \cite{CroleCT,JacobsCLTT}) to models of concurrency~\cite{DBLP:conf/csl/CattaniW96}.
Since its inception, category theory has challenged the traditional foundations of mathematics, namely in set theory, by dealing with collections that are too large to be sets. 
Often, it is possible to set things up well for the problem at hand while failing to capture the full generality of the categorical constructions.

Formalisation is a good way to test the limits of foundational choices, because a formal development must respect those choices throughout.
There can be no resort to arguments or constructions by analogy or implied generalisation, especially in formalisations developed mechanically with a proof assistant.
In this essay, we present a new mechanisation of category theory, refining two previous developments in higher-order logic, and investigate the foundational issues.

Higher-order logic (HOL) is a simple but expressive formal system suitable for the formalisation of many pieces of mathematics.
As a result, it is the logic implemented by many proof assistants in which formal mathematics has been developed.
HOL has a standard semantics in set theory, and therefore cannot capture large categorical constructions directly.
However, it can be extended with extra axioms asserting the existence of large classes.

We formalise the category of sets, the simplest foundationally tricky category, in higher-order logic so extended.
We try to fit naturally into the idiom of the logic while still being able to express some basic but foundationally-challenging categorical results.
We comment on the limitations of our approach, compare our mechanisation to others, and make brief speculations on what a more satisfying mechanisation of category theory would require and would look like.
%}
\section{Higher-Order Logic}%505/400%{
\newcommand{\bool}{\ensuremath{\mathsf{bool}}}
Higher-order logic (HOL) is a formal system that has proved popular for formalising purely mathematical results as well as properties of computer hardware and software systems.
HOL is a natural-deduction calculus with the syntax of the simply typed lambda calculus.
A term of Boolean type is called a \emph{formula}.
HOL has four formulae specified as axioms and a dozen rules of inference; a \emph{theorem}, $\vdash\phi$, is a formula $\phi$ proved from the axioms using the rules.
The HOL logic is implemented by several mechanical proof assistants, including Isabelle~\cite{DBLP:conf/tphol/WenzelPN08}, HOL4~\cite{DBLP:conf/tphol/SlindN08}, and HOL-Light~\cite{DBLP:conf/tphol/Harrison09a}.
Our development was done in HOL4, inspired by existing mechanisations \cite{Katovsky,DBLP:journals/entcs/OKeefe04} in Isabelle.

Every term $t$ has a unique type $\tau$ (this is written $t:\tau$), and the most general type for an unannotate term can be inferred automatically.
A type is either a type variable or a type operator applied to argument types (an operator taking no arguments is a type constant).
Terms whose types include type variables are said to be \emph{polymorphic}.
For example, there is a polymorphic constant $=$, whose type is $\alpha\to\alpha\to\bool$, representing equality at every type $\alpha$.
In the semantics of HOL, the meaning of a type is a non-empty set, and the meaning of a (non-polymorphic) term is an element of its type.
(A polymorphic term is interpreted as a function taking a set for each type variable and returning an element of the resulting type.)

A \emph{predicate} is a term of type $\alpha\to\bool$ for some type $\alpha$.
The type $\alpha\to\bool$ can be abbreviated by $\alpha\;\mathsf{set}$, reinforces the idea that types represent sets: a predicate on $\alpha$ is the characteristic function of a set of elements of type $\alpha$.
HOL4 includes much support for the representation of sets as predicates; we will use mathematical notation (such as $\{f\;x\mid P\;x\}$) for HOL sets.

Boolean connectives can be defined as functions in HOL, for example conjunction has type $\bool\to\bool\to\bool$.
In addition to the standard connectives and quantifiers, HOL includes a \emph{Hilbert choice} term that, given a predicate $P$ as argument, denotes an arbitrary (but fixed) element $c$ such that $P\; c$ holds, if any such element exists, otherwise denotes an arbitrary element (of the right type).
Hilbert choice is defined using a version of the axiom of choice, which is one of the axioms of HOL.
The primitive rules of inference include, for example, modus ponens, reflexivity of equality, and generalization (universal quantification) of free variables.
Typically, one also uses derived rules of inference that abbreviate applications of several primitive ones.

HOL provides principles for defining new types and new (term) constants.
The primitive types include function types ($\alpha\to\beta$ with arguments $\alpha$ and $\beta$) and Booleans ($\bool$).
A new type can be defined after proving that a certain predicate on an existing type is non-empty.
Standard types defined in HOL include the type $\mathsf{unit}$ with a single element $()$, the product type operator, producing a type $\alpha\times\beta$ from arguments $\alpha$ and $\beta$, and (its dual) the sum type operator $\alpha+\beta$.
Generalising sum types, it is possible to define a new type to represent a record given the desired names and types of the record fields.
New terms can be defined in terms of existing ones, like in a functional programming language.
%}
\section{Composable Morphisms and Categories}%1273/1400%{
Category theory is an abstract theory of functions and composition.
A category is an arena in which composition takes place, and consists of \emph{morphisms}, abstract functions, \emph{objects}, the possible domains and codomains of the morphisms, and a \emph{composition law}, obeying certain conditions.
We define a type of morphisms in HOL as a polymorphic record $(\alpha,\beta,\gamma)\;\mathsf{morphism}=\langle\mathtt{dom}:\alpha,\,\mathtt{cod}:\beta,\,\mathtt{map}:\gamma\rangle$.
We use a polymorphic record for categories as well, abbreviating $(\alpha,\alpha,\beta)\;\mathsf{morphism}$ by $(\alpha,\beta)\;\mathsf{mor}$:
\begin{align*}
(\alpha,\beta)\;\mathsf{category}=\langle&\mathtt{obj}:\alpha\;\mathsf{set},\,\mathtt{mor}:(\alpha,\beta)\;\mathsf{mor}\;\mathsf{set},\,\mathtt{id}:\alpha\to\beta,\\&\mathtt{comp}:(\alpha,\beta)\;\mathsf{mor}\to(\alpha,\beta)\;\mathsf{mor}\to\beta\rangle
\end{align*}
Thus an $(\alpha,\beta)\;\mathsf{category}$ has objects of type $\alpha$ and morphisms with a map field of type $\beta$.
The $\mathtt{id}$ and $\mathtt{comp}$ fields, intended to assign an identity morphism to every object and a composite morphism to every pair of composable morphisms, do not return full morphisms, because their $\mathtt{dom}$ and $\mathtt{cod}$ fields are determined by the conditions on a category, rather we define a function $\mathtt{id\_in}\;c\;x=\langle\mathtt{dom}=x,\,\mathtt{cod}=x,\,\mathtt{map}=c.\mathtt{id}\;x\rangle$ and $\mathtt{compose\_in}$ similarly.

As a very simple example, we might define the discrete category (which has no morphisms except identity morphisms) on a set $s$ as follows:
\begin{align*}
\mathtt{discrete\_cat}\;s=\langle&\mathtt{obj}=s,\,\mathtt{mor}=\{\mathtt{discrete\_mor}\;x\mid x\in s\},\\&\mathtt{id}=\lambda{x}.\;(),\,\mathtt{comp}=\lambda{f,g}.\;()\rangle
\end{align*}
where $\mathtt{discrete\_mor}\;x=\langle\mathtt{dom}=x,\,\mathtt{cod}=x,\,\mathtt{map}=()\rangle$.
If $s:\alpha\;\mathsf{set}$ then $\mathtt{discrete\_cat}\;s:(\alpha,\mathsf{unit})\;\mathsf{category}$.
Every category has an opposite category, which provides another example definition:
\begin{align*}
\mathtt{op\_cat}\;c=\langle&\mathtt{obj}=c.\mathtt{obj},\,\mathtt{mor}=\{\mathtt{op\_mor}\;f\mid f\in c.\mathtt{mor}\},\,\mathtt{id}=c.\mathtt{id},\\&\mathtt{comp}=\lambda{f,g}.\;c.\mathtt{comp}\;(\mathtt{op\_mor}\;g)\;(\mathtt{op\_mor}\;f)\rangle
\end{align*}
where $\mathtt{op\_mor}\;f=\langle\mathtt{dom}=f.\mathtt{cod},\,\mathtt{cod}=f.\mathtt{dom},\,\mathtt{map}=f.\mathtt{map}\rangle$.

We will look at two previous formalisations of category theory in detail, one by Greg O'Keefe in 2004~\cite{DBLP:journals/entcs/OKeefe04} and another by Alex Katovsky in 2010~\cite{Katovsky}.
Both also use a polymorphic record type for categories.
However, their categories have two additional fields of type $\beta\to\alpha$ intended to assign a domain and codomain to each morphism: there is no separate type of morphisms, and maps do not have (categorical) types except in the context of a category.
The advantage of keeping morphisms independent of categories (also done by Simpson~\cite{Simpson04}) is that notions like composability and composition can be defined generically then applied when there is no containing category.

Functors and natural transformations can be defined as instances of morphisms (between categories and between functors respectively) rather than as new record types.
For example, we use $(\alpha,\beta,\gamma,\delta)\;\mathsf{functor}$ to abbreviate the type \[((\alpha,\beta)\;\mathsf{category},(\gamma,\delta)\;\mathsf{category},(\alpha,\beta)\;\mathsf{mor}\to(\gamma,\delta)\;\mathsf{mor})\;\mathsf{morphism}\] whose instances we intend to be functors from an $(\alpha,\beta)\;\mathsf{category}$ to a $(\gamma,\delta)\;\mathsf{category}$.
The $\mathtt{map}$ field of a functor gives its action on morphisms; following Katovsky we omit the action on objects from the record, since it can be defined (using Hilbert choice) in terms of the action on identity morphisms.
Instances of the $\mathsf{morphism}$ record are not immediately attached to a category, but it could be argued that all composable morphisms occur in some category.
For example, functors are the morphisms in a category of categories.
However, this notion is problematic for several reasons, one of which is that objects in our categories must all have the same type, but we make use of functors between categories of different types.
Indeed, the separation of elements into different types in the semantics of HOL, which is a feature common to all type theories, presents difficulties whenever we want to collect elements across types into a totality.

Categories are abstract structures--many different things can play the roles of objects and morphisms--so it is natural to use a polymorphic type to model categories in HOL.
The polymorphism enables the same definition of $\mathtt{id\_in}$, for example, to be used for categories with all different types.
At the same time, polymorphism prevents us from collecting all categories in a single HOL set: in forming a term of type $(\alpha,\beta)\;\mathsf{category}\;\mathsf{set}$ we fix the types $\alpha$ and $\beta$, and therefore the set denoted cannot contain, for example, an element of type $(\alpha\times\alpha,\beta)\;\mathsf{category}$.

Coquand~\cite{DBLP:conf/lics/Coquand86} has shown that a category of categories cannot exist when working in a sufficiently strong logic, because it leads to paradox.
It is a useful idea to consider, nonetheless: for example, given two categories we can define a category, their product, that has the universal property of a categorical product to which we would like to apply general theorems about products.
The usual mathematical workaround is to stratify categories into bands of different sizes, and use the category of (relatively) small categories, which is itself not small.
This stratification can be achieved, to some extent, by \emph{universe polymorphism} in Coq (a proof assistant for dependent type theory, see~\cite{DBLP:conf/tphol/Bertot08}), as in Huet and Sa{\"i}bi's mechanisation~\cite{DBLP:conf/birthday/HuetS00}.
When we define the product of an $(\alpha,\beta)\;\mathsf{category}$ and a $(\gamma,\delta)\;\mathsf{category}$, however, it has type $(\alpha\times\gamma,\beta\times\delta)\;\mathsf{category}$.
Terms with these types could not all be objects of a $(\tau_1,\tau_2)\;\mathsf{category}$ for any (fixed) types $\tau_1$ and $\tau_2$.

Having looked at some of the problems due to the type system and our use of a polymorphic record, we return to describing our development.
An element of the $\mathsf{category}$ type is not necessarily a category.
We define a predicate $\mathtt{category\_axioms}:(\alpha,\beta)\;\mathsf{category}\to\mathsf{bool}$ that checks whether a record satisfies the conditions required of a category (composition is associative, every composable pair has a composite, and so on), and include a hypothesis that the predicate is true in our theorems about categories.
We can prove, for example, $\vdash\forall{c}.\;\mathtt{category\_axioms}\;c\implies\mathtt{category\_axioms}\;(\mathtt{op\_cat}\;c)$.

As noted by Katovsky, we need to impose an additional restriction that the identity and composition fields send elements outside their domain to a specific ``undefined'' value, which we call $\mathtt{ARB}$.
For example, if $x,y\notin c.\mathtt{obj}$ then we want $c.\mathtt{id}\;x=c.\mathtt{id}\;y$ even though the value of $c.\mathtt{id}\;x$ will never feature in any proof within the category $c$.
We call this kind of restriction \emph{extensionality}.
It is thanks to extensionality that two different constructions of the same category can be proved equal in HOL.
We impose the same restriction on other structures involving partial functions, like functors and natural transformations, for example the morphism map of a functor $G$ is restricted to $G.\mathtt{dom}.\mathtt{mor}$.
A non-extensional function (one that takes values other than $\mathtt{ARB}$ outside its desired domain) can easily be made extensional by changing its value at the relevant points: we use $\mathtt{restrict}\;f\;s=\lambda{e}.\;\mathtt{if}\;e\in s\;\mathtt{then}\;f\;e\;\mathtt{else}\;\mathtt{ARB}$ to restrict $f:\alpha\to\beta$ to $s:\alpha\;\mathsf{set}$.
As we will see, it is important to respect extensionality whenever possible; thus, for example, the actual definition of $\mathtt{id\_in}$ mentioned above is wrapped by a call to $\mathtt{restrict}$ on the set $c.\mathtt{obj}$ even though $c.\mathtt{id}$ is also restricted.
We define $\mathtt{is\_category}\;c=\mathtt{category\_axioms}\;c\land\mathtt{extensional\_category}\;c$, where the second conjunct ensures $c.\mathtt{id}$ and $c.\mathtt{comp}$ are extensional.
In a dependently typed setting, both the category axioms and extensionality can be encoded directly in the definition of the $\mathsf{category}$ type (as done in~\cite{DBLP:conf/birthday/HuetS00,Sozeau,Megacz} for example).

Extensionality enables us to characterise equality between natural transformations as follows
\begin{align*}
\vdash\forall{\eta,\mu}.\;&\mathtt{is\_nt}\;\eta\land\mathtt{is\_nt}\;\mu\land(\eta.\mathtt{dom} = \mu.\mathtt{dom})\land(\eta.\mathtt{cod} = \mu.\mathtt{cod})\land{}\\
&(\forall{x}.\;x\in \eta.\mathtt{dom}.\mathtt{dom}.\mathtt{obj}\implies(\eta.\mathtt{map}\;x= \mu.\mathtt{map}\;x))\implies (\eta = \mu)
\end{align*}
(and similarly for categories and functors).
Given a functor $F$, we can define an identity natural transformation whose component at $x$ is the identity morphism for $F$'s action on $x$.
Our theorem about natural transformation equality is used to prove, for example, 
\[\vdash\forall{\eta}.\;\mathtt{is\_nt}\;\eta\implies(\eta\circ\mathtt{id\_nt}\;\eta.\mathtt{dom} = \eta)\]
because our definition of natural transformation composition (the $\circ$ operator above) produces an extensional natural transformation, so comparison with $\eta$ depends only on categorical properties.
We have defined, for any two categories, the category of functors between them with natural transformations as morphisms, where $\mathtt{id\_nt}$ provides identity morphisms.
%mention postcomp_functor as an example of something proved using functor categories?

An alternative approach to categories gives a set of morphisms, called a \emph{hom}, for each type (pair of objects) rather than giving all the morphisms at once.
This has not been formalised in HOL, but is used by Huet and Sa{\"i}bi, for example.
We can define homs after categories: $\mathtt{hom}\;c\;x\;y=\{f\mid f.\mathtt{dom}=x\land f.\mathtt{cod}=y\land f\in c.\mathtt{mor}\}$.
An advantage of starting with homs instead might be that we could put off mentioning the collection of all morphisms.
We will return to this point in Section~\ref{Yoneda} when describing locally small categories.

Another choice in how to formalise categories is whether to include objects at all: we might avoid the need for an $\mathtt{obj}$ field by identifying objects with identity morphisms, as explained in pages 41--43 of \cite{DBLP:books/daglib/0023249}.
We have not seen this idea mechanised before; it would be interesting to see the ramifications of doing so on a development.
%}
\section{A Category of Classes and of Sets}%874/1400%{
\label{Set}
\newcommand{\Set}{\ensuremath{\mathbf{Set}}}
The category $\Set$ of sets has sets and objects and (typed) functions as morphisms.
A natural approach to defining $\Set$ in HOL is as an instance of the $\mathsf{category}$ record where $\mathtt{obj}:\alpha\;\mathsf{set}\;\mathsf{set}$ and the map field of each morphism is a function $\alpha\to\alpha$.
This approach is the one taken by O'Keefe, which we follow by defining a category of ``sets within a universe'', $\mathtt{ens\_cat}\;u$, whose set of objects is $u:\alpha\;\mathsf{set}\;\mathsf{set}$ and whose morphisms are of the form $f:(\alpha\;\mathsf{set},\alpha\to\alpha)\;\mathsf{mor}$ such that $x\in f.\mathtt{dom}\implies f.\mathtt{map}\;x\in f.\mathtt{cod}$ (and $f.\mathtt{map}$ is extensional on $f.\mathtt{dom}$).
The $\mathtt{ens\_cat}\;u$ category captures one important property of the category of sets, namely, that the morphisms are functions under composition.
It has precedent in Mac Lane's textbook on category theory~\cite{MacLaneCFTWM}, which defines $\mathbf{Ens}_u$ as above for the purpose of generalising arguments in $\Set$ to larger collections $u$ than that of all sets.
However, in our polymorphic setting, $\mathtt{ens\_cat}$ does not capture the idea that \emph{every} set should be an object, and therefore fails to have many properties the category of sets ought to have.

The problem is that $\Set$ is usually formulated in an untyped setting, and when translated to the typed setting it includes functions from sets of elements of one type to those of another.
For example, there is a function from the set of strings $\{\text{``an''},\text{``object''},\text{``in''},\text{``Set''}\}$ to the set of numbers $\{2,3,6\}$ that returns the length of a string, but in HOL, using idiomatic encodings, the former set would have type $\mathsf{string}\;\mathsf{set}$ while the latter would be a $\mathsf{num}\;\mathsf{set}$, and they cannot both be instances of $\alpha\;\mathsf{set}$ at the same time (since $\mathsf{string}$ and $\mathsf{num}$ are different types).
Clearly, this is a problem at the level of types, so remains even if we take $u$ to be the universal set (i.e., constantly true predicate) of type $\alpha\;\mathsf{set}\;\mathsf{set}$.

More generally, consider the relationship in any formalisation between the collection of morphisms $c.\mathtt{mor}$ in a category and the notion of a set.
If $c.\mathtt{mor}$ is itself a set, then there is no category whose morphisms are all the functions between sets, since no set can contain all functions <ref: Cantor?>, so $\Set$ cannot be formalised.
(If we define categories in terms of homs instead, a similar problem comes up when considering, for example, the category of functors from $\Set$ to itself <really?>.)
So if we want $\Set$ we must arrange for $c.\mathtt{mor}$ to be a \emph{class}: some kind of collection that can be larger than a set.

We can introduce classes into HOL by means of a new type, $\mathsf{zfset}$, representing sets in an axiomatic set theory such as ZFC.
Contrary to the way types are usually introduced in HOL, that is, by definition, the type $\mathsf{zfset}$ is created as a new primitive type (extending the logic) and its properties are asserted as new axioms of HOL.
The new axioms are (higher-order versions of) the axioms of ZFC.
We also define new terms for ZFC set membership ($\mathtt{in}:\mathsf{zfset}\to\mathsf{zfset}\to\mathsf{bool}$), set union, functions as graphs, and so on.
The effect on the semantics is that types must be interpreted as classes because any existing polymorphic type might be instantiated with $\mathsf{zfset}$; the constantly true predicate of type $\mathsf{zfset}\;\mathsf{set}$ now represents the class of all ZFC sets.
This method of accessing set theory within the HOL logic was introduced by Mike Gordon \cite{DBLP:conf/tphol/Gordon96} (and independently by Bob Solovay, see~\cite{DBLP:conf/ictac/Obua06}) and is implemented in both HOL4 and Isabelle~\cite{DBLP:conf/ictac/Obua06}.
We use it, following Katovksy, to define a non-polymorphic category of sets with $\mathtt{set\_cat}.\mathtt{obj}:\mathsf{zfset}\;\mathsf{set}$ and $\mathtt{set\_cat}.\mathtt{mor}:\mathsf{zfset}\;\mathsf{set}$ also, since functions between ZFC sets can be encoded as ZFC sets.

It would be reasonable to formalise all categories non-polymorphically, using sets and classes, so our record would have an $\mathtt{obj}$ field of type $\mathtt{zfset}\;\mathtt{set}$ (although it might be better to use $\mathtt{obj}:\alpha$ and a convention to only intanstiate $\alpha$ by $\mathsf{zfset}\;\mathsf{set}$ or $\mathsf{zfset}\;\mathsf{set}\;\mathsf{set}$ and so on, to allow arbitrarily large categories).
This approach matches a mathematical view of categories based on set theory extnded with proper classes (as in~\cite{MacLaneCFTWM} for example) if we take $\mathtt{zfset}$ seriously as our representation of sets.
However, in HOL we have a competing representation of sets, namely the HOL types.
If we formalise categories purely in terms of $\mathsf{zfset}$, then our categories remain disconnected from any other theories we have formalised in HOL using types such as $\mathsf{num}$ and $\mathsf{string}$.
It is for this reason we consider the polymorphic approach to be idiomatic.

Nevertheless, we need to use the ``untyped'' $\mathtt{set\_cat}$ if we want to formalise the many properties of $\Set$ that are lost on $\mathtt{ens\_cat}$.
The reason much mathematics is encoded in set theory in the first place is that the universe of sets supports the encoding of almost all mathematical objects.
We can tap into this idea by treating a HOL set (of type $\alpha\;\mathsf{set}$ for some type $\alpha$) as a ZFC set, in particular by finding a representative element of type $\mathsf{zfset}$ to which the HOL set corresponds.
Since HOL types now represent (possibly large) classes, we can only hope to encode small HOL sets.
Following ideas from Katovksy, we can use an injection into the elements
<definition of IsSmall, the zfrep, and rep functor, for other types>

Working with $\mathtt{ens\_cat}$ in HOL is easier than with $\mathtt{set\_cat}$, because the morphisms are based on HOL functions directly rather than encodings of ZFC functions as ZFC sets.
We would expect $\mathtt{ens\_cat}$ to be more general than $\mathtt{set\_cat}$, since it is parameterised over an arbitrary universe of sets, and happily we can prove that $\mathtt{set\_cat}$ is isomorphic as a category to $\mathtt{ens\_cat}\;\{s:\mathsf{zfset}\;\mathsf{set}\mid\mathtt{is\_small}\;s\}$.
<isomorphism between set cat and ens cat at a specific type>
%}
\section{Binary Products and Other Limits}%187/250%{
\label{limits}
Like many constructions in category theory (and in abstract mathematics generally), \emph{limits} can be presented in different, equivalent ways, at different levels of generality.
Examples of limits include products, which generalise Cartesian products of sets, and <..>.
<universal properties?>
<one fully general definition gives a limit as a universal cone, and one presentation of cones give them as objects in a certain comma category>
<we have defined comma categories and used them to define cones and limits>
<we have also instantiated this general definition to define binary products as <...> and then proved that they are characterised by their less abstract and possibly more familiar <....>>

<set cat has binary products. this is the first mechanisation of limits in HOL (but certainly not at all - refs) and reassuring for the HOLZF approach. the point of set cat is that it may be impossible to prove arbitrary ens cats have limits>

<a few words about the difficulties facing an attempt to work on exponential objects and adjunctions>
<namely: many equivalent formulations, but most of them would involve constructions that we can't make to be fully general>
%}
\section{The Yoneda Embedding}%317/500%{
\label{Yoneda}
\newcommand{\C}{\ensuremath{\mathbb{C}}}
\newcommand{\op}{\ensuremath{\sp{\mathrm{op}}}}
\newcommand{\blank}{\rule[0.5ex]{0.6em}{.4pt}}
<
The Yoneda embedding provides a representation of a category $\C$ in the category of presheaves $\widehat\C$.
A \emph{presheaf} is a functor from $\C\op$ to the category of sets.
Thus $\widehat\C$ is a functor category.
An embedding is a functor that is \emph{full} and \emph{faithful}, which means each map, induced by the functor, on morphisms of a fixed type is surjective and injective, respectively.
The importance of the Yoneda embedding comes from the fact that $\widehat{\C}$ inherits much structure from the category of sets (for example, the existence of small limits and colimits) so can be used when $\C$ itself lacks this structure.
The Yoneda lemma, used to prove that the Yoneda embedding is an embedding, is an important basic milestone in any development about the category of sets, and was one of the main results in both the HOL mechanisations we consider.

The Yoneda embedding sends an object $x$ in $\C$ to the \emph{contravariant hom functor} $\C(\blank,x)$, which in turn sends an object $y$ in $\C$ to the \emph{hom} $\C(y,x)=\{f:y\to x\text{ in $\C$}\}$.
In order for $\C(\blank,x)$ to be a set-valued presheaf, however, every hom $\C(y,x)$ must be a set.
A hom can fail to be a set if it is too large.
A category where every hom is a set is called \emph{locally small}, and it is only for locally small categories that the Yoneda embedding can be defined.
However the proof of the Yoneda lemma never mentions smallness explicitly, and the argument still goes through when we generalize from the category of sets to an arbitrary category whose objects are appropriately set-like and include the homs of $\C$.
>

<note O'Keefe does not prove the embedding is one, just proves the lemma (that the bijection exists)>

<statement for ens cat. proof basically as in Katovsky, but made simpler by avoiding representations>

<basically reuse the proof for set cat, to get zYfunctor, along with some theorems about embeddings being preserved etc.>

<discuss the difficulty with injectivity on objects and the tagging solution>
%}
\section{Conclusions}%38/500%{
<summary of issues facing mechanisations>
<related work in other systems esp. that can solve major foundational problems>
<It may be possible to do this kind of general abstract mathematics by working with a non-wellfounded set theory <ref?>.
%}
\bibliographystyle{plain}
\bibliography{essay}
\end{document}
% vim:fdm=marker:fmr=%{,%}
